
import { serve } from "https://deno.land/std@0.190.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.50.5";

const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
const supabase = createClient(supabaseUrl, supabaseKey);

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

interface TelegramUpdate {
  message?: {
    chat: { id: number };
    from: { id: number; first_name: string; username?: string };
    text?: string;
    contact?: { phone_number: string };
    voice?: { file_id: string };
  };
  callback_query?: {
    id: string;
    from: { id: number };
    message: { chat: { id: number } };
    data: string;
  };
}

interface Session {
  step: string;
  data: any;
  userId?: string;
  userProfile?: any;
  proposalData?: any;
}

// Fun√ß√£o para buscar usu√°rio pelo telefone na tabela profiles
async function findUserByPhone(phone: string) {
  console.log('üîç Buscando usu√°rio pelo telefone:', phone);
  
  // Normalizar telefone removendo caracteres especiais
  const normalizedPhone = phone.replace(/\D/g, '');
  console.log('üì± Telefone normalizado:', normalizedPhone);
  
  // Buscar na tabela profiles primeiro
  const { data: profile, error: profileError } = await supabase
    .from('profiles')
    .select('*')
    .or(`phone.eq.${phone},phone.eq.${normalizedPhone},phone.eq.+${normalizedPhone}`)
    .single();

  if (profileError && profileError.code !== 'PGRST116') {
    console.error('‚ùå Erro ao buscar perfil:', profileError);
  }

  if (profile) {
    console.log('‚úÖ Perfil encontrado:', profile);
    return {
      user_id: profile.user_id,
      name: profile.name,
      phone: profile.phone,
      email: null // Vamos buscar o email na tabela auth se necess√°rio
    };
  }

  console.log('‚ùå Usu√°rio n√£o encontrado pelo telefone');
  return null;
}

// Fun√ß√£o para salvar sess√£o
async function saveSession(telegramUserId: number, chatId: number, session: Session) {
  console.log('üíæ Salvando sess√£o:', { telegramUserId, chatId, session });
  
  const { error } = await supabase
    .from('telegram_sessions')
    .upsert({
      telegram_user_id: telegramUserId,
      chat_id: chatId,
      step: session.step,
      session_data: session.data || {},
      user_id: session.userId || null,
      user_profile: session.userProfile || {},
      updated_at: new Date().toISOString(),
      expires_at: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString()
    });

  if (error) {
    console.error('‚ùå Erro ao salvar sess√£o:', error);
  } else {
    console.log('‚úÖ Sess√£o salva com sucesso');
  }
}

// Fun√ß√£o para carregar sess√£o
async function loadSession(telegramUserId: number): Promise<Session> {
  console.log('üìÇ Carregando sess√£o para usu√°rio:', telegramUserId);
  
  const { data, error } = await supabase
    .from('telegram_sessions')
    .select('*')
    .eq('telegram_user_id', telegramUserId)
    .single();

  if (error || !data) {
    console.log('üÜï Criando nova sess√£o');
    return { step: 'start', data: {} };
  }

  console.log('‚úÖ Sess√£o carregada:', data);
  return {
    step: data.step,
    data: data.session_data || {},
    userId: data.user_id,
    userProfile: data.user_profile || {},
    proposalData: data.session_data?.proposalData || {}
  };
}

// Fun√ß√£o para enviar mensagem
async function sendMessage(chatId: number, text: string, replyMarkup?: any) {
  const botToken = Deno.env.get('TELEGRAM_BOT_TOKEN');
  
  const response = await fetch(`https://api.telegram.org/bot${botToken}/sendMessage`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      chat_id: chatId,
      text,
      reply_markup: replyMarkup,
      parse_mode: 'HTML'
    })
  });

  return await response.json();
}

// Fun√ß√£o para transcrever √°udio usando OpenAI
async function transcribeAudio(fileId: string): Promise<string | null> {
  try {
    const botToken = Deno.env.get('TELEGRAM_BOT_TOKEN');
    const openaiKey = Deno.env.get('OPENAI_API_KEY');

    // Primeiro, obter informa√ß√µes do arquivo
    const fileResponse = await fetch(`https://api.telegram.org/bot${botToken}/getFile?file_id=${fileId}`);
    const fileData = await fileResponse.json();
    
    if (!fileData.ok) {
      console.error('‚ùå Erro ao obter informa√ß√µes do arquivo:', fileData);
      return null;
    }

    // Baixar o arquivo de √°udio
    const audioResponse = await fetch(`https://api.telegram.org/file/bot${botToken}/${fileData.result.file_path}`);
    const audioBuffer = await audioResponse.arrayBuffer();

    // Transcrever usando OpenAI Whisper
    const formData = new FormData();
    formData.append('file', new Blob([audioBuffer], { type: 'audio/ogg' }), 'voice.ogg');
    formData.append('model', 'whisper-1');

    const transcriptionResponse = await fetch('https://api.openai.com/v1/audio/transcriptions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${openaiKey}`
      },
      body: formData
    });

    const transcriptionData = await transcriptionResponse.json();
    
    if (transcriptionData.text) {
      console.log('‚úÖ √Åudio transcrito:', transcriptionData.text);
      return transcriptionData.text;
    }

    return null;
  } catch (error) {
    console.error('‚ùå Erro ao transcrever √°udio:', error);
    return null;
  }
}

// Fun√ß√£o para processar texto/descri√ß√£o da proposta usando IA
async function processProposalDescription(description: string): Promise<any> {
  try {
    const openaiKey = Deno.env.get('OPENAI_API_KEY');

    const prompt = `
Analise a seguinte descri√ß√£o de proposta e extraia as informa√ß√µes estruturadas:

Descri√ß√£o: "${description}"

Retorne um JSON com as seguintes informa√ß√µes:
{
  "title": "t√≠tulo da proposta",
  "service_description": "descri√ß√£o do servi√ßo",
  "detailed_description": "descri√ß√£o detalhada",
  "value": n√∫mero ou null,
  "delivery_time": "prazo de entrega",
  "observations": "observa√ß√µes adicionais",
  "missing_info": ["lista", "de", "informa√ß√µes", "que", "ainda", "faltam"],
  "client_info": {
    "name": "nome do cliente se mencionado",
    "email": "email se mencionado",
    "company": "empresa se mencionada"
  }
}

Se alguma informa√ß√£o n√£o estiver clara ou estiver faltando, inclua no array "missing_info".
Informa√ß√µes essenciais: t√≠tulo, descri√ß√£o do servi√ßo, valor (se aplic√°vel), prazo de entrega.
`;

    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${openaiKey}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        model: 'gpt-4o-mini',
        messages: [
          { role: 'system', content: 'Voc√™ √© um assistente especializado em an√°lise de propostas comerciais. Sempre retorne respostas em JSON v√°lido.' },
          { role: 'user', content: prompt }
        ],
        temperature: 0.3
      })
    });

    const data = await response.json();
    const content = data.choices[0].message.content;
    
    // Tentar extrair JSON do conte√∫do
    const jsonMatch = content.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      return JSON.parse(jsonMatch[0]);
    }

    return JSON.parse(content);
  } catch (error) {
    console.error('‚ùå Erro ao processar descri√ß√£o com IA:', error);
    return null;
  }
}

// Fun√ß√£o para criar proposta no banco
async function createProposal(userId: string, proposalData: any) {
  console.log('üìù Criando proposta:', proposalData);

  const { data, error } = await supabase
    .from('proposals')
    .insert({
      user_id: userId,
      title: proposalData.title,
      service_description: proposalData.service_description,
      detailed_description: proposalData.detailed_description,
      value: proposalData.value,
      delivery_time: proposalData.delivery_time,
      observations: proposalData.observations,
      status: 'rascunho'
    })
    .select()
    .single();

  if (error) {
    console.error('‚ùå Erro ao criar proposta:', error);
    return null;
  }

  console.log('‚úÖ Proposta criada:', data);
  return data;
}

// Fun√ß√£o para enviar proposta por email
async function sendProposalByEmail(proposalId: string, clientEmail: string) {
  try {
    const { data, error } = await supabase.functions.invoke('send-proposal-email', {
      body: {
        proposalId,
        clientEmail
      }
    });

    if (error) {
      console.error('‚ùå Erro ao enviar email:', error);
      return false;
    }

    console.log('‚úÖ Email enviado com sucesso');
    return true;
  } catch (error) {
    console.error('‚ùå Erro ao enviar email:', error);
    return false;
  }
}

const handler = async (req: Request): Promise<Response> => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const update: TelegramUpdate = await req.json();
    console.log('üì® Update recebido:', JSON.stringify(update, null, 2));

    // Processar mensagem
    if (update.message) {
      const { chat, from, text, contact, voice } = update.message;
      const chatId = chat.id;
      const telegramUserId = from.id;

      console.log(`üë§ Usu√°rio: ${from.first_name} (ID: ${telegramUserId})`);

      // Carregar sess√£o
      let session = await loadSession(telegramUserId);

      // Comando /start - sempre reinicia
      if (text === '/start') {
        console.log('üîÑ Comando /start recebido, reiniciando conversa');
        session = { step: 'start', data: {} };
        await saveSession(telegramUserId, chatId, session);
        
        await sendMessage(chatId, 
          'ü§ñ <b>Ol√°! Bem-vindo ao Bot de Propostas!</b>\n\n' +
          'üì± Para come√ßar, preciso que voc√™ compartilhe seu n√∫mero de telefone para identificar sua conta.\n\n' +
          'üëá Clique no bot√£o abaixo para compartilhar:',
          {
            keyboard: [[{ text: 'üì± Compartilhar Telefone', request_contact: true }]],
            resize_keyboard: true,
            one_time_keyboard: true
          }
        );
        return new Response('OK', { headers: corsHeaders });
      }

      // Verificar se √© compartilhamento de contato
      if (contact) {
        console.log('üì± Contato recebido:', contact.phone_number);
        
        const user = await findUserByPhone(contact.phone_number);
        
        if (user) {
          session.userId = user.user_id;
          session.userProfile = user;
          session.step = 'main_menu';
          
          await saveSession(telegramUserId, chatId, session);
          console.log('‚úÖ Usu√°rio autenticado:', user);
          
          await sendMessage(chatId, 
            `‚úÖ <b>Autenticado com sucesso!</b>\n\n` +
            `üëã Ol√°, <b>${user.name || 'Usu√°rio'}</b>!\n\n` +
            `üéØ O que voc√™ gostaria de fazer?`,
            {
              inline_keyboard: [
                [{ text: 'üìù Criar Nova Proposta', callback_data: 'create_proposal' }],
                [{ text: 'üìã Minhas Propostas', callback_data: 'my_proposals' }],
                [{ text: '‚ùì Ajuda', callback_data: 'help' }]
              ]
            }
          );
        } else {
          await sendMessage(chatId, 
            '‚ùå <b>Telefone n√£o encontrado!</b>\n\n' +
            'üì± Este n√∫mero n√£o est√° cadastrado no sistema.\n\n' +
            'üí° Certifique-se de que voc√™ j√° possui uma conta no sistema e que seu telefone est√° cadastrado no seu perfil.'
          );
        }
        return new Response('OK', { headers: corsHeaders });
      }

      // Verificar se usu√°rio est√° autenticado
      if (!session.userId) {
        await sendMessage(chatId, 
          'üîê <b>Voc√™ precisa se autenticar primeiro!</b>\n\n' +
          'üì± Use o comando /start para compartilhar seu telefone.'
        );
        return new Response('OK', { headers: corsHeaders });
      }

      // Processar mensagem de voz
      if (voice) {
        if (session.step === 'waiting_proposal_description') {
          await sendMessage(chatId, 'üé§ <b>Processando √°udio...</b>\n\n‚è≥ Aguarde enquanto transcrevo sua mensagem.');
          
          const transcription = await transcribeAudio(voice.file_id);
          
          if (transcription) {
            console.log('üìù Transcri√ß√£o:', transcription);
            // Processar como se fosse texto
            const processedData = await processProposalDescription(transcription);
            
            if (processedData) {
              session.proposalData = { ...session.proposalData, ...processedData };
              
              if (processedData.missing_info && processedData.missing_info.length > 0) {
                session.step = 'requesting_missing_info';
                await saveSession(telegramUserId, chatId, session);
                
                await sendMessage(chatId, 
                  `üìù <b>Informa√ß√µes processadas!</b>\n\n` +
                  `‚ùó Ainda precisamos de algumas informa√ß√µes:\n\n` +
                  `${processedData.missing_info.map((info: string) => `‚Ä¢ ${info}`).join('\n')}\n\n` +
                  `üí¨ Por favor, forne√ßa essas informa√ß√µes via texto ou √°udio:`
                );
              } else {
                // Todas as informa√ß√µes est√£o completas
                session.step = 'confirm_proposal';
                await saveSession(telegramUserId, chatId, session);
                
                await sendMessage(chatId, 
                  `‚úÖ <b>Proposta processada com sucesso!</b>\n\n` +
                  `üìã <b>Resumo:</b>\n` +
                  `üéØ <b>T√≠tulo:</b> ${processedData.title}\n` +
                  `üíº <b>Servi√ßo:</b> ${processedData.service_description}\n` +
                  `üí∞ <b>Valor:</b> ${processedData.value ? `R$ ${processedData.value}` : 'A definir'}\n` +
                  `‚è±Ô∏è <b>Prazo:</b> ${processedData.delivery_time || 'A definir'}\n\n` +
                  `‚ùì Confirma a cria√ß√£o desta proposta?`,
                  {
                    inline_keyboard: [
                      [
                        { text: '‚úÖ Confirmar', callback_data: 'confirm_create_proposal' },
                        { text: '‚ùå Cancelar', callback_data: 'cancel_proposal' }
                      ]
                    ]
                  }
                );
              }
            } else {
              await sendMessage(chatId, 
                '‚ùå <b>N√£o consegui processar o √°udio.</b>\n\n' +
                'üí¨ Tente novamente ou envie as informa√ß√µes por texto.'
              );
            }
          } else {
            await sendMessage(chatId, 
              '‚ùå <b>Erro ao transcrever √°udio.</b>\n\n' +
              'üí¨ Tente novamente ou envie as informa√ß√µes por texto.'
            );
          }
        } else {
          await sendMessage(chatId, 
            'üé§ <b>√Åudio n√£o esperado neste momento.</b>\n\n' +
            'üí¨ Use o menu para navegar pelas op√ß√µes.'
          );
        }
        return new Response('OK', { headers: corsHeaders });
      }

      // Processar texto
      if (text) {
        // Aguardando descri√ß√£o da proposta
        if (session.step === 'waiting_proposal_description') {
          await sendMessage(chatId, 'ü§ñ <b>Processando sua descri√ß√£o...</b>\n\n‚è≥ Aguarde enquanto analiso as informa√ß√µes.');
          
          const processedData = await processProposalDescription(text);
          
          if (processedData) {
            session.proposalData = { ...session.proposalData, ...processedData };
            
            if (processedData.missing_info && processedData.missing_info.length > 0) {
              session.step = 'requesting_missing_info';
              await saveSession(telegramUserId, chatId, session);
              
              await sendMessage(chatId, 
                `üìù <b>Informa√ß√µes processadas!</b>\n\n` +
                `‚ùó Ainda precisamos de algumas informa√ß√µes:\n\n` +
                `${processedData.missing_info.map((info: string) => `‚Ä¢ ${info}`).join('\n')}\n\n` +
                `üí¨ Por favor, forne√ßa essas informa√ß√µes via texto ou √°udio:`
              );
            } else {
              // Todas as informa√ß√µes est√£o completas
              session.step = 'confirm_proposal';
              await saveSession(telegramUserId, chatId, session);
              
              await sendMessage(chatId, 
                `‚úÖ <b>Proposta processada com sucesso!</b>\n\n` +
                `üìã <b>Resumo:</b>\n` +
                `üéØ <b>T√≠tulo:</b> ${processedData.title}\n` +
                `üíº <b>Servi√ßo:</b> ${processedData.service_description}\n` +
                `üí∞ <b>Valor:</b> ${processedData.value ? `R$ ${processedData.value}` : 'A definir'}\n` +
                `‚è±Ô∏è <b>Prazo:</b> ${processedData.delivery_time || 'A definir'}\n\n` +
                `‚ùì Confirma a cria√ß√£o desta proposta?`,
                {
                  inline_keyboard: [
                    [
                      { text: '‚úÖ Confirmar', callback_data: 'confirm_create_proposal' },
                      { text: '‚ùå Cancelar', callback_data: 'cancel_proposal' }
                    ]
                  ]
                }
              );
            }
          } else {
            await sendMessage(chatId, 
              '‚ùå <b>N√£o consegui processar sua descri√ß√£o.</b>\n\n' +
              'üí¨ Tente ser mais espec√≠fico sobre o servi√ßo, valor e prazo de entrega.'
            );
          }
          return new Response('OK', { headers: corsHeaders });
        }

        // Aguardando informa√ß√µes adicionais
        if (session.step === 'requesting_missing_info') {
          const additionalInfo = await processProposalDescription(text);
          
          if (additionalInfo) {
            // Merge das informa√ß√µes
            session.proposalData = {
              ...session.proposalData,
              ...additionalInfo,
              title: additionalInfo.title || session.proposalData.title,
              service_description: additionalInfo.service_description || session.proposalData.service_description,
              detailed_description: additionalInfo.detailed_description || session.proposalData.detailed_description,
              value: additionalInfo.value || session.proposalData.value,
              delivery_time: additionalInfo.delivery_time || session.proposalData.delivery_time,
              observations: additionalInfo.observations || session.proposalData.observations
            };

            if (additionalInfo.missing_info && additionalInfo.missing_info.length > 0) {
              await saveSession(telegramUserId, chatId, session);
              
              await sendMessage(chatId, 
                `üìù <b>Informa√ß√µes atualizadas!</b>\n\n` +
                `‚ùó Ainda faltam:\n\n` +
                `${additionalInfo.missing_info.map((info: string) => `‚Ä¢ ${info}`).join('\n')}\n\n` +
                `üí¨ Continue fornecendo as informa√ß√µes:`
              );
            } else {
              session.step = 'confirm_proposal';
              await saveSession(telegramUserId, chatId, session);
              
              await sendMessage(chatId, 
                `‚úÖ <b>Todas as informa√ß√µes coletadas!</b>\n\n` +
                `üìã <b>Resumo final:</b>\n` +
                `üéØ <b>T√≠tulo:</b> ${session.proposalData.title}\n` +
                `üíº <b>Servi√ßo:</b> ${session.proposalData.service_description}\n` +
                `üí∞ <b>Valor:</b> ${session.proposalData.value ? `R$ ${session.proposalData.value}` : 'A definir'}\n` +
                `‚è±Ô∏è <b>Prazo:</b> ${session.proposalData.delivery_time || 'A definir'}\n\n` +
                `‚ùì Confirma a cria√ß√£o desta proposta?`,
                {
                  inline_keyboard: [
                    [
                      { text: '‚úÖ Confirmar', callback_data: 'confirm_create_proposal' },
                      { text: '‚ùå Cancelar', callback_data: 'cancel_proposal' }
                    ]
                  ]
                }
              );
            }
          } else {
            await sendMessage(chatId, 
              '‚ùå <b>N√£o consegui processar as informa√ß√µes adicionais.</b>\n\n' +
              'üí¨ Tente ser mais claro sobre os detalhes que ainda faltam.'
            );
          }
          return new Response('OK', { headers: corsHeaders });
        }

        // Aguardando email do cliente
        if (session.step === 'waiting_client_email') {
          const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
          
          if (emailRegex.test(text)) {
            session.data.clientEmail = text;
            session.step = 'confirm_send_email';
            await saveSession(telegramUserId, chatId, session);
            
            await sendMessage(chatId, 
              `üìß <b>Email confirmado:</b> ${text}\n\n` +
              `‚ùì Deseja enviar a proposta para este email?`,
              {
                inline_keyboard: [
                  [
                    { text: '‚úÖ Enviar', callback_data: 'send_email_confirmed' },
                    { text: '‚ùå Cancelar', callback_data: 'back_to_proposal' }
                  ]
                ]
              }
            );
          } else {
            await sendMessage(chatId, 
              '‚ùå <b>Email inv√°lido!</b>\n\n' +
              'üìß Por favor, digite um email v√°lido:'
            );
          }
          return new Response('OK', { headers: corsHeaders });
        }

        // Mensagem n√£o reconhecida
        await sendMessage(chatId, 
          '‚ùì <b>N√£o entendi sua mensagem.</b>\n\n' +
          'üè† Use /start para voltar ao menu principal.'
        );
      }
    }

    // Processar callback queries (bot√µes)
    if (update.callback_query) {
      const { id, from, message, data } = update.callback_query;
      const chatId = message!.chat.id;
      const telegramUserId = from.id;

      let session = await loadSession(telegramUserId);

      // Responder ao callback
      await fetch(`https://api.telegram.org/bot${Deno.env.get('TELEGRAM_BOT_TOKEN')}/answerCallbackQuery`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ callback_query_id: id })
      });

      console.log('üîò Callback recebido:', data);

      switch (data) {
        case 'create_proposal':
          session.step = 'waiting_proposal_description';
          session.proposalData = {};
          await saveSession(telegramUserId, chatId, session);
          
          await sendMessage(chatId, 
            'üìù <b>Vamos criar uma nova proposta!</b>\n\n' +
            'üé§ <b>Descreva em texto ou √°udio:</b>\n' +
            '‚Ä¢ Qual servi√ßo ser√° prestado\n' +
            '‚Ä¢ Valor da proposta (se souber)\n' +
            '‚Ä¢ Prazo de entrega\n' +
            '‚Ä¢ Detalhes importantes\n' +
            '‚Ä¢ Informa√ß√µes do cliente (nome, empresa)\n\n' +
            'üí° <b>Dica:</b> Seja o mais detalhado poss√≠vel. A IA ir√° analisar e identificar se falta alguma informa√ß√£o importante!'
          );
          break;

        case 'my_proposals':
          // Buscar propostas do usu√°rio
          const { data: proposals, error } = await supabase
            .from('proposals')
            .select('*')
            .eq('user_id', session.userId)
            .order('created_at', { ascending: false })
            .limit(10);

          if (error) {
            await sendMessage(chatId, '‚ùå Erro ao buscar propostas.');
            break;
          }

          if (proposals.length === 0) {
            await sendMessage(chatId, 
              'üìã <b>Voc√™ ainda n√£o tem propostas criadas.</b>\n\n' +
              'üìù Que tal criar sua primeira proposta?',
              {
                inline_keyboard: [
                  [{ text: 'üìù Criar Nova Proposta', callback_data: 'create_proposal' }]
                ]
              }
            );
          } else {
            const proposalsList = proposals.map((p, index) => 
              `${index + 1}. <b>${p.title}</b>\n` +
              `   üí∞ ${p.value ? `R$ ${p.value}` : 'Valor n√£o definido'}\n` +
              `   üìÖ ${new Date(p.created_at).toLocaleDateString('pt-BR')}\n` +
              `   üìä Status: ${p.status}\n`
            ).join('\n');

            await sendMessage(chatId, 
              `üìã <b>Suas √∫ltimas propostas:</b>\n\n${proposalsList}\n\n` +
              `üí° Para gerenciar suas propostas, acesse o sistema web.`
            );
          }
          break;

        case 'help':
          await sendMessage(chatId, 
            '‚ùì <b>Ajuda - Bot de Propostas</b>\n\n' +
            'üîß <b>O que posso fazer:</b>\n' +
            '‚Ä¢ Criar propostas via texto ou √°udio\n' +
            '‚Ä¢ Analisar descri√ß√µes com IA\n' +
            '‚Ä¢ Enviar propostas por email\n' +
            '‚Ä¢ Listar suas propostas\n\n' +
            'üí° <b>Comandos:</b>\n' +
            '‚Ä¢ /start - Reiniciar conversa\n\n' +
            'üìû <b>Suporte:</b>\n' +
            'Entre em contato pelo sistema web para ajuda t√©cnica.',
            {
              inline_keyboard: [
                [{ text: 'üè† Menu Principal', callback_data: 'main_menu' }]
              ]
            }
          );
          break;

        case 'main_menu':
          session.step = 'main_menu';
          await saveSession(telegramUserId, chatId, session);
          
          await sendMessage(chatId, 
            `üè† <b>Menu Principal</b>\n\n` +
            `üëã Ol√°, <b>${session.userProfile?.name || 'Usu√°rio'}</b>!\n\n` +
            `üéØ O que voc√™ gostaria de fazer?`,
            {
              inline_keyboard: [
                [{ text: 'üìù Criar Nova Proposta', callback_data: 'create_proposal' }],
                [{ text: 'üìã Minhas Propostas', callback_data: 'my_proposals' }],
                [{ text: '‚ùì Ajuda', callback_data: 'help' }]
              ]
            }
          );
          break;

        case 'confirm_create_proposal':
          const proposal = await createProposal(session.userId!, session.proposalData);
          
          if (proposal) {
            session.data.lastProposalId = proposal.id;
            session.step = 'proposal_created';
            await saveSession(telegramUserId, chatId, session);
            
            await sendMessage(chatId, 
              `‚úÖ <b>Proposta criada com sucesso!</b>\n\n` +
              `üìã <b>ID:</b> ${proposal.id.substring(0, 8)}...\n` +
              `üéØ <b>T√≠tulo:</b> ${proposal.title}\n\n` +
              `üìß <b>Deseja enviar por email?</b>`,
              {
                inline_keyboard: [
                  [{ text: 'üìß Enviar por Email', callback_data: 'send_by_email' }],
                  [{ text: 'üè† Menu Principal', callback_data: 'main_menu' }]
                ]
              }
            );
          } else {
            await sendMessage(chatId, '‚ùå Erro ao criar proposta. Tente novamente.');
          }
          break;

        case 'cancel_proposal':
          session.step = 'main_menu';
          session.proposalData = {};
          await saveSession(telegramUserId, chatId, session);
          
          await sendMessage(chatId, 
            '‚ùå <b>Cria√ß√£o de proposta cancelada.</b>\n\nüè† Voltando ao menu principal...',
            {
              inline_keyboard: [
                [{ text: 'üìù Criar Nova Proposta', callback_data: 'create_proposal' }],
                [{ text: 'üìã Minhas Propostas', callback_data: 'my_proposals' }],
                [{ text: '‚ùì Ajuda', callback_data: 'help' }]
              ]
            }
          );
          break;

        case 'send_by_email':
          session.step = 'waiting_client_email';
          await saveSession(telegramUserId, chatId, session);
          
          await sendMessage(chatId, 
            'üìß <b>Envio por Email</b>\n\n' +
            '‚úâÔ∏è Digite o email do cliente para enviar a proposta:'
          );
          break;

        case 'send_email_confirmed':
          const emailSent = await sendProposalByEmail(session.data.lastProposalId, session.data.clientEmail);
          
          if (emailSent) {
            await sendMessage(chatId, 
              `‚úÖ <b>Email enviado com sucesso!</b>\n\n` +
              `üìß A proposta foi enviada para: <b>${session.data.clientEmail}</b>\n\n` +
              `üéâ O cliente receber√° um link para visualizar e responder √† proposta.`,
              {
                inline_keyboard: [
                  [{ text: 'üè† Menu Principal', callback_data: 'main_menu' }]
                ]
              }
            );
          } else {
            await sendMessage(chatId, 
              '‚ùå <b>Erro ao enviar email.</b>\n\n' +
              '‚ö†Ô∏è Verifique se o email est√° correto e tente novamente.',
              {
                inline_keyboard: [
                  [{ text: 'üîÑ Tentar Novamente', callback_data: 'send_by_email' }],
                  [{ text: 'üè† Menu Principal', callback_data: 'main_menu' }]
                ]
              }
            );
          }
          break;

        case 'back_to_proposal':
          session.step = 'proposal_created';
          await saveSession(telegramUserId, chatId, session);
          
          await sendMessage(chatId, 
            `üìã <b>Proposta criada!</b>\n\n` +
            `üéØ O que deseja fazer agora?`,
            {
              inline_keyboard: [
                [{ text: 'üìß Enviar por Email', callback_data: 'send_by_email' }],
                [{ text: 'üè† Menu Principal', callback_data: 'main_menu' }]
              ]
            }
          );
          break;

        default:
          await sendMessage(chatId, '‚ùì A√ß√£o n√£o reconhecida.');
          break;
      }
    }

    return new Response('OK', { headers: corsHeaders });
  } catch (error) {
    console.error('‚ùå Erro no webhook:', error);
    return new Response('Error', { status: 500, headers: corsHeaders });
  }
};

serve(handler);
